

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>框架介绍 &mdash; CNStream 用户手册 2020-02-24 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜索" href="../search.html" />
    <link rel="next" title="内置模块" href="../modules/Module.html" />
    <link rel="prev" title="概述" href="../overview/Overview.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> CNStream 用户手册
          

          
          </a>

          
            
            
              <div class="version">
                2020-02-24
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">目录</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../copyright/Copyright.html">版权声明</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview/Overview.html">概述</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">框架介绍</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id2">核心框架</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cnstream-pipeline">cnstream::Pipeline类</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cnstream-module">cnstream::Module类</a></li>
<li class="toctree-l2"><a class="reference internal" href="#cnstream-cnframeinfo">cnstream::CNFrameInfo类</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../modules/Module.html">内置模块</a></li>
<li class="toctree-l1"><a class="reference internal" href="../programming_mode/ProgrammingModel.html">编程模型</a></li>
<li class="toctree-l1"><a class="reference internal" href="../configure/Configure.html">环境配置</a></li>
<li class="toctree-l1"><a class="reference internal" href="../customize_module/how_to_implement_module.html">创建自定义模块</a></li>
<li class="toctree-l1"><a class="reference internal" href="../application/how_to_build_apps.html">创建应用程序</a></li>
<li class="toctree-l1"><a class="reference internal" href="../tool/Inspect_tool.html">Inspect工具</a></li>
<li class="toctree-l1"><a class="reference internal" href="../FAQ/FAQ.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../release_notes/release_notes.html">Release Notes</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">CNStream 用户手册</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
      <li>框架介绍</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/framework/Framework.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="id1">
<h1>框架介绍<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="section" id="id2">
<h2>核心框架<a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>CNStream SDK基于管道（Pipeline）和事件总线（EventBus）实现了模块式数据处理流程。</p>
<p>Pipeline类似一个流水线，把复杂问题的解决方案分解成一个个处理阶段，然后依次处理。一个处理阶段的结果是下一个处理阶段的输入。
Pipeline模式的类模型由三部分组成：</p>
<ul class="simple">
<li><p>Pipeline：代表执行流。</p></li>
<li><p>Module：代表执行流中的一个阶段。</p></li>
<li><p>Context：是Module执行时的上下文信息。</p></li>
</ul>
<p>EventBus模式主要用来处理事件，包括三个部分：</p>
<ul class="simple">
<li><p>事件源（Event Source）：将消息发布到事件总线上。</p></li>
<li><p>事件监听器（Observer/Listener）：监听器订阅事件。</p></li>
<li><p>事件总线（EventBus）：事件发布到总线上时被监听器接收。</p></li>
</ul>
<p>Pipeline和EventBus模式实现了CNStream框架。相关组成以及在CNStream SDK实现中对应关系如下：</p>
<ul class="simple">
<li><p>Pipeline：对应 <strong>cnstream::Pipeline</strong> 类。</p></li>
<li><p>Module：Pipeline的每个处理阶段是一个组件，对应 <strong>cnstream::Module</strong> 类。每一个具体的mdule都是 <strong>cnstream::Module</strong> 的派生类。</p></li>
<li><p>FrameInfo：Pipeline模式的Context，对应 <strong>cnstream::CNFrameInfo</strong> 类。</p></li>
<li><p>Event-bus和Event：分别对应 <strong>cnstream::EventBus</strong> 类和 <strong>cnstream::Event</strong> 类。</p></li>
</ul>
<p>CNStream既支持构造线性模式的pipeline，也支持搭建非线性形状的pipeline，例如split、join模式，如下所示：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">ModuleA</span><span class="o">------</span><span class="n">ModuleB</span><span class="o">------</span><span class="n">ModuleC</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>            <span class="o">|------</span><span class="n">ModuleB</span><span class="o">------|</span>
<span class="n">ModuleA</span><span class="o">----</span> <span class="o">|</span>                   <span class="o">|</span> <span class="o">----</span> <span class="n">ModuleD</span>
            <span class="o">|------</span><span class="n">ModuleC</span><span class="o">------|</span>
</pre></div>
</div>
</div>
<div class="section" id="cnstream-pipeline">
<h2>cnstream::Pipeline类<a class="headerlink" href="#cnstream-pipeline" title="永久链接至标题">¶</a></h2>
<p><strong>cnstream::Pipeline</strong> 类实现了pipeline的搭建、module管理、以及module的调度执行。在module自身不传递数据时，负责module之间的数据传递。此外，该类集成事件总线，提供注册事件监听器的机制，使用户能够接收事件。例如stream EOS等。Pipeline通过隐含的深度可控的队列来连接module，使用module的输入队列连接上游的module。CNStream也提供了根据JSON配置文件来搭建pipeline的接口。在不重新编译源码的情况下，通过修改配置文件搭建不同的pipeline。</p>
<div class="admonition attention">
<p class="admonition-title">注意</p>
<div class="line-block">
<div class="line">Pipeline的source module是没有输入队列，pipeline中不会为source module启动线程，也就是说pipeline不会调度source module。source module通过pipeline的 <code class="docutils literal notranslate"><span class="pre">ProvideData</span></code> 接口向下游模块发送数据和启动内部线程。</div>
</div>
</div>
<p><strong>cnstream::Pipeline</strong> 类在 <code class="docutils literal notranslate"><span class="pre">cnstream_pipeline.hpp</span></code> 文件内定义，主要接口如下。 <code class="docutils literal notranslate"><span class="pre">cnstream_pipeline.hpp</span></code> 文件存放于 <code class="docutils literal notranslate"><span class="pre">modules/core/include</span></code> 目录下。源代码中有详细的注释，这里仅给出必要的说明。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>class Pipeline {
  ...
 public:
  //  根据ModuleConfigs或者JSON配置文件来搭建pipeline。
  //  实现这两者前提是能够根据类名字创建类实例即反射(reflection)机制。
  //  在cnstream::Module类介绍中会进行描述。
  int BuildPipeline(const std::vector&lt;CNModuleConfig&gt;&amp; configs);
  int BuildPipelineByJSONFile(const std::string&amp; config_file) noexcept(false);

  ...

  // 向某个module发送CNFrameInfo,比如向一个pipeline的source module发送图像数据。
  bool ProvideData(const Module* module, std::shared_ptr&lt;CNFrameInfo&gt; data);

  ...
  // 开始和结束pipeline service。
  bool Start();
  bool Stop();

  ...
  // 根据moduleName获得module instance。
  Module* GetModule(const std::string&amp; moduleName);
  ...
};
</pre></div>
</div>
<p>ModuleConfigs（JSON）的示例如下。JSON配置文件支持C和C++风格的注释。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>{
  {
    &quot;source&quot; : {
     &quot;class_name&quot; : &quot;DataSource&quot;,     //指定module使用哪个类来创建。
     &quot;parallelism&quot; : 0, //framework创建的module线程数目。source module不使用这个字段。
     &quot;next_modules&quot; : [&quot;inference&quot;], //下一个连接模块的名字，可以有多个。
     &quot;custom_params&quot; : {             //当前module的参数。
       &quot;source_type&quot; : &quot;ffmpeg&quot;,    //使用ffmpeg作为demuxer。
       &quot;output_type&quot; : &quot;mlu&quot;,      //解码图像输出到MLU内存。
       &quot;decoder_type&quot; : &quot;mlu&quot;,    //使用CNDecoder。
       &quot;reuse_cndec_buf&quot;: &quot;true&quot;, //复用CNDecoder的输出image buffer。
       &quot;device_id&quot; : 0           //MLU设备id。
     }
   },

  &quot;inference&quot; : {
    &quot;class_name&quot; : &quot;M220Inference&quot;,
    &quot;parallelism&quot; : 16,            //framwork创建的模块线程数，也是输入队列的数目。
    &quot;max_input_queue_size&quot; : 32,   //输入队列的最大长度。
    &quot;next_modules&quot; : [&quot;fps_stats&quot;],
    &quot;custom_params&quot; : {
          // 使用寒武纪工具生成的离线模型。
      &quot;model_path&quot; : &quot;/data/models/resnet34_ssd.cambricon&quot;,
      &quot;func_name&quot; : &quot;subnet0&quot;,
      &quot;device_id&quot; : 0,
      &quot;batch_size&quot; : 4, //M220 Inference实现中batch的最大数目。
      &quot;worker_num&quot; : 8  //M220 Inference内部创建的线程池的线程数目。
    }
  },

  &quot;fps_stats&quot; : {
    &quot;class_name&quot; : &quot;cnstream::FpsStats&quot;,
    &quot;parallelism&quot; : 4,
    &quot;max_input_queue_size&quot; : 32
  }
}
</pre></div>
</div>
</div>
<div class="section" id="cnstream-module">
<h2>cnstream::Module类<a class="headerlink" href="#cnstream-module" title="永久链接至标题">¶</a></h2>
<p>CNStream SDK要求所有的Module类使用统一接口和数据结构 <strong>cnstream::CNFrameInfo</strong> 。从框架上要求了module的通用性，并简化了module的编写。实现具体module的方式如下：</p>
<ul class="simple">
<li><p>从 <strong>cnstream::Module</strong> 派生：适合功能单一，内部不需要并发处理的场景。Module实现只需要关注对CNFrameInfo的处理，由框架传递（transmit）CNFrameInfo。</p></li>
<li><p>从 <strong>cnstream::ModuleEx</strong> 派生： Module除了处理CNFrameInfo之外，还负责CNFrameInfo的传递，以及保证数据顺序带来的灵活性，从而可以实现内部并发。</p></li>
</ul>
<p>配置搭建pipeline的基础是实现根据module类名字创建module实例，因此具体module类还需要继承 <strong>cnstream::ModuleCreator</strong> 。</p>
<p>一个module的实例，会使用一个或者多个线程对多路数据流进行处理，每一路数据流使用pipeline范围内唯一的 <code class="docutils literal notranslate"><span class="pre">stream_id</span></code> 进行标识。</p>
<p><strong>cnstream::Module</strong> 类在 <code class="docutils literal notranslate"><span class="pre">cnstream_module.hpp</span></code> 文件定义，主要接口如下。<code class="docutils literal notranslate"><span class="pre">cnstream_module.hpp</span></code> 文件存放在 <code class="docutils literal notranslate"><span class="pre">modules/core/include</span></code> 文件夹下。源代码中有详细的注释，这里仅给出必要的说明。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>class Module {
 public:

  // 一个pipeline中，每个module名字必须唯一。
  explicit Module(const std::string &amp;name);
  ...

  // 必须实现Open、Close和Process接口。这三个接口会被pipeline调用。
  // 通过Open接口接收参数，分配资源。
  // 通过Close接口释放资源。
  // 通过Process接口接收需要处理的数据，并更新CNFrameInfo。
  virtual bool Open(ModuleParamSet param_set) = 0;
  virtual void Close() = 0;

  // 特别注意：Process处理多个stream的数据, 由多线程调用。
  // 单路stream的CNFrameInfo会在一个线程中处理。
  // Process的返回值：
  //  0 -- 表示已经处理完毕，传递数据操作由框架完成。
  //  1 -- 表示已经接收数据，在后台进行后续处理。传递数据操作由module自身完成。
  //  &lt; 0 -- 表示有错误产生。
  virtual int Process(std::shared_ptr&lt;CNFrameInfo&gt; data) = 0;

  ...
  // 向pipeline发送消息，如Stream EOS。
  bool PostEvent(EventType type, const std::string &amp;msg) const;
};
</pre></div>
</div>
</div>
<div class="section" id="cnstream-cnframeinfo">
<h2>cnstream::CNFrameInfo类<a class="headerlink" href="#cnstream-cnframeinfo" title="永久链接至标题">¶</a></h2>
<p><strong>cnstream::CNFrameInfo</strong> 类是module之间传递的数据结构，即pipeline的Context。该类在 <code class="docutils literal notranslate"><span class="pre">cnstream_frame.hpp</span></code> 文件中定义。<code class="docutils literal notranslate"><span class="pre">cnstream_frame.hpp</span></code> 文件存放在 <code class="docutils literal notranslate"><span class="pre">modules/core/include</span></code> 文件夹下。这个数据结构包括了CNDataFrame和CNFrameInfo。</p>
<p>CNFrameInfo用于数据和推理结果，并对pipeline中单路stream使用的DataFrame的数目进行限制，我们称之为pipeline的并发深度，接口如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>cnstream::SetParallelism(int value)；
</pre></div>
</div>
<p>CNDataFrame中集成了SyncedMemory。基于MLU平台的异构性，在应用程序中，当某个具体的module处理的数据可能需要在CPU上或者MLU上时，SyncedMem实现了CPU和MLU（Host和Device）之间的数据同步。通过SyncedMem，module可以自身决定访问保存在MLU或者CPU上的数据，从而简化module的编写，接口如下：</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="p">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">CNSyncedMemory</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">[</span><span class="n">CN_MAX_PLANES</span><span class="p">];</span>
</pre></div>
</div>
<p>CNDataFrame中的SyncedMem支持deep copy或者复用已有的内存。当管理CNDecoder和Inference之间的image buffer时，可以进行deep copy和复用decoder的buffer内存。decoder和后续的inference处理完全解耦，但是会带来dev2dev copy的代价。</p>
<p>另外，CNInferObject不仅提供对常规推理结果的数据存储机制，还提供用户自定义数据格式的接口 <code class="docutils literal notranslate"><span class="pre">extra_attributes_</span></code> ，方便用户使用其他格式传递数据，如JSON格式。</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="p">::</span><span class="nb">map</span><span class="o">&lt;</span><span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="p">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">extra_attributes_</span><span class="p">;</span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../modules/Module.html" class="btn btn-neutral float-right" title="内置模块" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../overview/Overview.html" class="btn btn-neutral float-left" title="概述" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Cambricon

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>